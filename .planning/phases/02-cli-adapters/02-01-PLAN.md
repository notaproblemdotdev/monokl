---
phase: 02-cli-adapters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/monocli/adapters/__init__.py
  - src/monocli/adapters/detection.py
  - tests/test_detection.py
autonomous: true
must_haves:
  truths:
    - "Application can detect if glab CLI is installed and authenticated"
    - "Application can detect if acli CLI is installed and authenticated"
    - "Detection results are cached to avoid repeated system calls"
    - "Missing or unauthenticated CLIs can be identified for section hiding"
  artifacts:
    - path: "src/monocli/adapters/__init__.py"
      provides: "Adapter package initialization and exports"
    - path: "src/monocli/adapters/detection.py"
      provides: "CLIDetector and DetectionRegistry for CLI availability checking"
    - path: "tests/test_detection.py"
      provides: "Unit tests for detection logic and auth validation"
  key_links:
    - from: "src/monocli/adapters/detection.py"
      to: "shutil.which"
      via: "CLI executable discovery"
    - from: "src/monocli/adapters/detection.py"
      to: "CLIAuthError detection"
      via: "Trial command execution"
---

<objective>
Create a unified CLI detection mechanism that can discover available CLIs (glab, acli), validate their authentication status, and provide a registry for the application to query which data sources are available.

Purpose: This enables the application to auto-detect which platforms the user has configured (DASH-04) and gracefully hide sections for unavailable CLIs (CONFIG-02).
Output: DetectionRegistry class with CLI availability and auth status checking, plus comprehensive tests.
</objective>

<execution_context>
@/Users/pg/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/pg/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/monocli/async_utils.py
@src/monocli/exceptions.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adapter package structure and detection module</name>
  <files>src/monocli/adapters/__init__.py, src/monocli/adapters/detection.py</files>
  <action>
Create the adapters package with detection functionality:

1. Create `src/monocli/adapters/__init__.py` that exports:
   - CLIDetector
   - DetectionRegistry
   - DetectionResult (TypedDict)

2. Create `src/monocli/adapters/detection.py` with:
   
   DetectionResult TypedDict:
   - cli_name: str (e.g., "glab", "acli")
   - is_installed: bool
   - is_authenticated: bool
   - error_message: str | None
   
   CLIDetector class:
   - __init__(cli_name: str, test_args: list[str])
     - cli_name: executable name
     - test_args: command to test auth (e.g., ["auth", "status"])
   - async check_availability() -> DetectionResult
     - Uses shutil.which() to check installation
     - Runs test_args command to validate auth
     - Catches CLINotFoundError -> is_installed=False
     - Catches CLIAuthError -> is_authenticated=False
     - Returns DetectionResult with all fields
   
   DetectionRegistry class:
   - __init__() with empty dict of detectors
   - register(detector: CLIDetector) -> None
   - async detect_all() -> dict[str, DetectionResult]
     - Runs all detectors concurrently using asyncio.gather
     - Returns {cli_name: DetectionResult}
   - get_available() -> list[str] (CLI names that are installed AND authenticated)
   - is_available(cli_name: str) -> bool

3. Add proper type hints and docstrings following existing patterns in async_utils.py

Key design decisions:
- Cache results at the registry level after first detect_all() call
- Trial commands should be lightweight (auth status, not full data fetch)
- Use existing CLIError/CLIAuthError from exceptions.py for error handling
  </action>
  <verify>python -c "from monocli.adapters import CLIDetector, DetectionRegistry; print('Imports OK')"</verify>
  <done>
- Adapters package exists with __init__.py exports
- detection.py has CLIDetector and DetectionRegistry classes
- Imports work without errors
- mypy src/monocli/adapters/detection.py passes type checking
  </done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for detection functionality</name>
  <files>tests/test_detection.py</files>
  <action>
Create tests/test_detection.py with comprehensive coverage:

1. Test CLIDetector:
   - test_detector_init: Verify proper initialization
   - test_check_availability_installed_and_authed:
     - Mock shutil.which to return path
     - Mock successful subprocess call
     - Assert DetectionResult with is_installed=True, is_authenticated=True
   - test_check_availability_not_installed:
     - Mock shutil.which to return None
     - Assert DetectionResult with is_installed=False
   - test_check_availability_installed_not_authed:
     - Mock shutil.which to return path
     - Mock subprocess to raise CLIAuthError
     - Assert DetectionResult with is_installed=True, is_authenticated=False

2. Test DetectionRegistry:
   - test_registry_init: Empty state
   - test_register_detector: Add detectors
   - test_detect_all_concurrent:
     - Register multiple detectors
     - Mock all to return different results
     - Verify asyncio.gather behavior (parallel execution)
     - Verify results dict has all cli_names
   - test_get_available: Returns only clis with both installed=True and authenticated=True
   - test_is_available: Boolean check for specific CLI
   - test_detect_all_caching:
     - First call runs detection
     - Second call returns cached results (mock subprocess not called again)

3. Use pytest-asyncio for async test support
4. Use unittest.mock to patch shutil.which and subprocess calls
5. Import fixtures from conftest.py if needed

Test patterns to follow:
- Use @pytest.mark.asyncio decorator
- Mock at the right level (shutil.which for installation, subprocess for auth)
- Test error conditions explicitly
  </action>
  <verify>uv run pytest tests/test_detection.py -v</verify>
  <done>
- All detection tests pass
- Coverage includes happy path and error cases
- Tests verify parallel execution with asyncio.gather
- Tests verify caching behavior
  </done>
</task>

</tasks>

<verification>
1. Import test: python -c "from monocli.adapters import CLIDetector, DetectionRegistry, DetectionResult"
2. Type check: mypy src/monocli/adapters/ passes
3. Test run: uv run pytest tests/test_detection.py -v (all pass)
4. Verify structure:
   - CLIDetector has check_availability() method
   - DetectionRegistry has detect_all(), get_available(), is_available() methods
   - DetectionResult TypedDict has required fields
</verification>

<success_criteria>
- CLIDetector can check if a CLI is installed using shutil.which
- CLIDetector can validate authentication by running a test command
- DetectionRegistry can run multiple detectors concurrently
- DetectionRegistry caches results to avoid repeated system calls
- DetectionResult provides clear status for each CLI
- All detection logic has unit tests with mocked subprocess calls
- Application can query which CLIs are available for data fetching
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-adapters/02-01-SUMMARY.md`
</output>
